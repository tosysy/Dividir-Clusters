<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sistema FAT</title>
<script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
<link rel="stylesheet" href="styles.css">

</head>
<body>
    <a href="index.html" class="btn-home" id="homeLink" style="animation: fadeInButton 0.5s ease-out;">üè† <span>P√°gina de Inicio</span></a>
    <style>
        @keyframes fadeInButton {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>

    <div class="container">
        <!-- Panel izquierdo: Generador PDF -->
        <div class="panel">
            <h2>üìÑ Generador de Plantilla PDF</h2>
            
            <div class="form-group">
                <label for="divs">N√∫mero de cl√∫sters</label>
                <input type="number" id="divs" value="4" min="2" max="20">
            </div>

            <div class="form-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="ddrsf">
                    <label for="ddrsf" style="margin: 0;">Mostrar booleanos (DDRSF)</label>
                </div>
            </div>

            <button onclick="generarPDF()">üöÄ Generar Plantilla PDF</button>

            <div class="divider"></div>

            <div style="background: #fef3c7; padding: 15px; border-radius: 10px; border-left: 4px solid #f59e0b;">
                <strong style="color: #92400e;">üí° Instrucciones:</strong>
                <p style="color: #78350f; margin-top: 8px; font-size: 0.9em;">
                    Configure el n√∫mero de cl√∫sters y active los booleanos si desea visualizar 
                    las columnas D, D, R, S, F en la tabla FAT. Al generar, se descargar√° 
                    autom√°ticamente un PDF con la estructura del sistema de archivos FAT.
                </p>
            </div>
        </div>

        <!-- Panel derecho: Explorador FAT -->
        <div class="panel">
            <h2>üìã Explorador del Sistema FAT</h2>

            <div class="form-group">
                <label for="comandoSelect">Comando</label>
                <select id="comandoSelect" onchange="actualizarFormulario()">
                    <option value="mkdir">üìÅ Crear directorio</option>
                    <option value="addfile">üìÑ A√±adir archivo</option>
                    <option value="copy">üìã Copiar</option>
                    <option value="move">‚úÇÔ∏è Mover</option>
                    <option value="delete">üóëÔ∏è Eliminar</option>
                </select>
            </div>

            <div id="formExtra"></div>

            <button onclick="agregarInstruccion()">‚ûï A√±adir Instrucci√≥n</button>

            <div class="divider"></div>

            <h3>üìÅ √Årbol del Sistema de Archivos</h3>
            <pre id="vista">/ (ra√≠z)</pre>

            <h3>üìä Estad√≠sticas</h3>
            <div style="padding: 15px; background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; border: 2px solid #bae6fd;">
                <span style="color: #0c4a6e; font-weight: 600;">M√°ximo de cl√∫sters: </span>
                <span class="stats-badge" id="maxClusters">0</span>
            </div>

            <h3>üìù Historial de Instrucciones</h3>
            <div id="listaInstrucciones">
                <div class="empty-state">
                    No hay instrucciones a√∫n. ¬°A√±ade la primera!
                </div>
            </div>
        </div>
    </div>

<script>
/* ============================================
   GENERADOR DE PDF
   ============================================ */
async function generarPDF() {
    const divs = parseInt(document.getElementById('divs').value);
    const mostrar_ddrsf = document.getElementById('ddrsf').checked;

    try {
        const url = 'assets/Plantilla_FAT.pdf';
        const arrayBuffer = await fetch(url).then(res => res.arrayBuffer());
        const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
        const page = pdfDoc.getPages()[0];
        const { width, height } = page.getSize();

        const cuadros = [
            { x: 107, y: height - 133 - 322, w: 173, h: 322, tipo: "FAT" },
            { x: 540, y: height - 107 - 349, w: 213, h: 349, tipo: "DIRECTORIO" }
        ];

        const filas = Math.ceil(divs / 2);

        cuadros.forEach(cuadro => {
            const {x, y, w, h, tipo} = cuadro;
            
            // Rect√°ngulo principal
            page.drawRectangle({ 
                x, y, width: w, height: h, 
                borderColor: PDFLib.rgb(0, 0, 0), 
                borderWidth: 1 
            });
            
            // L√≠nea vertical central
            page.drawLine({ 
                start: {x: x + w/2, y}, 
                end: {x: x + w/2, y: y + h}, 
                color: PDFLib.rgb(0, 0, 0), 
                thickness: 1 
            });

            // L√≠neas horizontales
            const altura_fila = h / filas;
            for (let i = 1; i < filas; i++) {
                page.drawLine({ 
                    start: {x: x, y: y + i * altura_fila}, 
                    end: {x: x + w, y: y + i * altura_fila}, 
                    color: PDFLib.rgb(0, 0, 0), 
                    thickness: 1 
                });
            }

            // Numeraci√≥n de cl√∫sters
            let contador = 1;
            const columnas = [x, x + w/2];

            for (let fila = 0; fila < filas; fila++) {
                const y_fila = y + h - fila * altura_fila;
                columnas.forEach(col => {
                    page.drawText(`C${contador}`, { 
                        x: col + 2, 
                        y: y_fila - 10, 
                        size: 8 
                    });

                    // Booleanos DDRSF
                    if (tipo === "FAT" && mostrar_ddrsf) {
                        const izquierda = ["D", "D", "R"];
                        const derecha = ["S", "F"];
                        const esp = (altura_fila + 20) / (izquierda.length + 1);
                        
                        izquierda.forEach((l, idx) => 
                            page.drawText(l, {
                                x: col + 7, 
                                y: y_fila - (idx + 1) * esp, 
                                size: 12
                            })
                        );
                        
                        derecha.forEach((l, idx) => 
                            page.drawText(l, {
                                x: col + 45, 
                                y: y_fila - (idx + 1) * esp, 
                                size: 12
                            })
                        );
                    }
                    contador++;
                });
            }
        });

        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: "application/pdf" });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = "Plantilla_FAT.pdf";
        link.click();

        // Mensaje de √©xito
        mostrarNotificacion("‚úÖ PDF generado exitosamente", "success");

    } catch (err) {
        console.error("Error generando PDF:", err);
        mostrarNotificacion("‚ùå Error al generar el PDF. Verifica que el archivo de plantilla exista.", "error");
    }
}

/* ============================================
   EXPLORADOR DEL SISTEMA FAT
   ============================================ */
let root = {nombre: "/", tipo: "dir", hijos: [], clusters: 0};
let instrucciones = [];
let maxClustersHistorico = 0;

function buscarNodo(ruta, nodo = root) {
    if (ruta === "/") return root;
    const partes = ruta.split("/").filter(Boolean);
    let actual = nodo;
    for (const p of partes) {
        actual = actual.hijos.find(h => h.nombre === p);
        if (!actual) return null;
    }
    return actual;
}

function generarDirectorios(nodo = root, path = "/") {
    let dirs = [path];
    nodo.hijos.filter(h => h.tipo === "dir").forEach(h => {
        const subPath = path === "/" ? `/${h.nombre}` : `${path}/${h.nombre}`;
        dirs = dirs.concat(generarDirectorios(h, subPath));
    });
    return dirs;
}

function generarElementos(nodo = root, path = "/") {
    let elems = [];
    if (path !== "/") elems.push({nombre: path, tipo: nodo.tipo});
    if (nodo.tipo === "dir") {
        nodo.hijos.forEach(h => {
            const subPath = path === "/" ? `/${h.nombre}` : `${path}/${h.nombre}`;
            elems = elems.concat(generarElementos(h, subPath));
        });
    }
    return elems;
}

function actualizarFormulario() {
    const cmd = document.getElementById('comandoSelect').value;
    const form = document.getElementById('formExtra');
    form.innerHTML = "";

    if (cmd === "mkdir") {
        form.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                <div class="form-group">
                    <label for="nombre">Nombre del directorio</label>
                    <input type="text" id="nombre" placeholder="ej. juegos">
                </div>
                <div class="form-group">
                    <label for="rutaSelect">Ubicaci√≥n destino</label>
                    <select id="rutaSelect"></select>
                </div>
            </div>
        `;
        llenarDirectorios("rutaSelect");
    }
    else if (cmd === "addfile") {
        form.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                <div class="form-group">
                    <label for="nombre">Nombre del archivo</label>
                    <input type="text" id="nombre" placeholder="ej. documento.txt">
                </div>
                <div class="form-group">
                    <label for="clusters">N√∫mero de cl√∫sters</label>
                    <input type="number" id="clusters" value="1" min="1">
                </div>
                <div class="form-group" style="grid-column: 1 / -1;">
                    <label for="rutaSelect">Ubicaci√≥n destino</label>
                    <select id="rutaSelect"></select>
                </div>
            </div>
        `;
        llenarDirectorios("rutaSelect");
    }
    else if (cmd === "copy" || cmd === "move") {
        form.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                <div class="form-group">
                    <label for="elementoSelect">Elemento a ${cmd === "copy" ? "copiar" : "mover"}</label>
                    <select id="elementoSelect"></select>
                </div>
                <div class="form-group">
                    <label for="rutaSelect">Ubicaci√≥n destino</label>
                    <select id="rutaSelect"></select>
                </div>
            </div>
        `;
        llenarElementos("elementoSelect");
        llenarDirectorios("rutaSelect");
    }
    else if (cmd === "delete") {
        form.innerHTML = `
            <div class="form-group">
                <label for="elementoSelect">Elemento a eliminar</label>
                <select id="elementoSelect"></select>
            </div>
        `;
        llenarElementos("elementoSelect");
    }
}

function llenarDirectorios(id) {
    const select = document.getElementById(id);
    const dirs = generarDirectorios();
    select.innerHTML = "";
    dirs.forEach(d => {
        const opt = document.createElement("option");
        opt.value = d;
        opt.textContent = d;
        select.appendChild(opt);
    });
}

function llenarElementos(id) {
    const select = document.getElementById(id);
    const elems = generarElementos();
    select.innerHTML = "";
    elems.forEach(e => {
        const opt = document.createElement("option");
        opt.value = e.nombre;
        opt.textContent = `${e.tipo === "dir" ? "üìÅ" : "üìÑ"} ${e.nombre}`;
        select.appendChild(opt);
    });
}

function agregarInstruccion() {
    const cmd = document.getElementById('comandoSelect').value;
    let instr = {cmd};

    try {
        if (cmd === "mkdir") {
            instr.nombre = document.getElementById('nombre').value.trim();
            if (!instr.nombre) throw new Error("El nombre no puede estar vac√≠o");
            instr.dest = document.getElementById('rutaSelect').value;
        }
        else if (cmd === "addfile") {
            instr.nombre = document.getElementById('nombre').value.trim();
            if (!instr.nombre) throw new Error("El nombre no puede estar vac√≠o");
            instr.clusters = parseInt(document.getElementById('clusters').value);
            if (instr.clusters < 1) throw new Error("El n√∫mero de cl√∫sters debe ser mayor a 0");
            instr.dest = document.getElementById('rutaSelect').value;
        }
        else if (cmd === "copy" || cmd === "move") {
            instr.elemento = document.getElementById('elementoSelect').value;
            instr.dest = document.getElementById('rutaSelect').value;
        }
        else if (cmd === "delete") {
            instr.elemento = document.getElementById('elementoSelect').value;
        }

        instrucciones.push(instr);
        actualizarLista();
        ejecutarInstr(instr);
        recalcularClusters();
        actualizarVista();
        recalcularMaximoClusters();
        
        mostrarNotificacion("‚úÖ Instrucci√≥n a√±adida correctamente", "success");
    } catch (error) {
        mostrarNotificacion("‚ùå " + error.message, "error");
    }
}

function actualizarLista() {
    const lista = document.getElementById('listaInstrucciones');
    
    if (instrucciones.length === 0) {
        lista.innerHTML = '<div class="empty-state">No hay instrucciones a√∫n. ¬°A√±ade la primera!</div>';
        return;
    }
    
    lista.innerHTML = "";
    instrucciones.forEach((i, idx) => {
        const div = document.createElement('div');
        div.className = "instr-item";
        
        const cmdText = {
            mkdir: "Crear dir",
            addfile: "A√±adir archivo",
            copy: "Copiar",
            move: "Mover",
            delete: "Eliminar"
        }[i.cmd] || i.cmd;
        
        let detalles = JSON.stringify(i);
        
        div.innerHTML = `
            <span class="instr-text">${idx + 1}. ${cmdText}: ${detalles}</span>
            <button class="btn-small" onclick="borrarInstr(${idx})">‚ùå</button>
        `;
        lista.appendChild(div);
    });
}

function borrarInstr(idx) {
    instrucciones.splice(idx, 1);
    actualizarLista();
    reconstruirDesdeCero();
    mostrarNotificacion("üóëÔ∏è Instrucci√≥n eliminada", "info");
}

function ejecutarInstr(i) {
    if (i.cmd === "mkdir") {
        const dest = buscarNodo(i.dest);
        if (dest) {
            let nombreFinal = i.finalName ?? i.nombre;
            if (i.finalName === undefined) {
                const existenteIdx = dest.hijos.findIndex(h => h.nombre === nombreFinal);
                if (existenteIdx !== -1) {
                    const reemplazar = i.reemplazar ?? confirm(`Ya existe \"${nombreFinal}\" en ${i.dest}. ¬øDeseas reemplazarlo? (Cancelar para renombrar)`);
                    if (reemplazar) {
                        dest.hijos.splice(existenteIdx, 1);
                        i.reemplazar = true;
                    } else {
                        i.reemplazar = false;
                        let nuevo = prompt("Introduce un nuevo nombre:", `${nombreFinal} (1)`);
                        if (!nuevo) { mostrarNotificacion("‚ÑπÔ∏è Operaci√≥n cancelada", "info"); return; }
                        nuevo = nuevo.trim();
                        while (dest.hijos.find(h => h.nombre === nuevo)) {
                            nuevo = prompt("Ese nombre ya existe. Introduce otro nombre:", `${nuevo} (1)`);
                            if (!nuevo) { mostrarNotificacion("‚ÑπÔ∏è Operaci√≥n cancelada", "info"); return; }
                            nuevo = nuevo.trim();
                        }
                        nombreFinal = nuevo;
                        i.finalName = nombreFinal;
                    }
                }
            }
            dest.hijos.push({nombre: nombreFinal, tipo: "dir", hijos: [], clusters: 1});
        }
    }
    else if (i.cmd === "addfile") {
        const dest = buscarNodo(i.dest);
        if (dest) {
            let nombreFinal = i.finalName ?? i.nombre;
            if (i.finalName === undefined) {
                const existenteIdx = dest.hijos.findIndex(h => h.nombre === nombreFinal);
                if (existenteIdx !== -1) {
                    const reemplazar = i.reemplazar ?? confirm(`Ya existe \"${nombreFinal}\" en ${i.dest}. ¬øDeseas reemplazarlo? (Cancelar para renombrar)`);
                    if (reemplazar) {
                        dest.hijos.splice(existenteIdx, 1);
                        i.reemplazar = true;
                    } else {
                        i.reemplazar = false;
                        let nuevo = prompt("Introduce un nuevo nombre:", `${nombreFinal} (1)`);
                        if (!nuevo) { mostrarNotificacion("‚ÑπÔ∏è Operaci√≥n cancelada", "info"); return; }
                        nuevo = nuevo.trim();
                        while (dest.hijos.find(h => h.nombre === nuevo)) {
                            nuevo = prompt("Ese nombre ya existe. Introduce otro nombre:", `${nuevo} (1)`);
                            if (!nuevo) { mostrarNotificacion("‚ÑπÔ∏è Operaci√≥n cancelada", "info"); return; }
                            nuevo = nuevo.trim();
                        }
                        nombreFinal = nuevo;
                        i.finalName = nombreFinal;
                    }
                }
            }
            dest.hijos.push({nombre: nombreFinal, tipo: "file", clusters: i.clusters});
        }
    }
    else if (i.cmd === "copy") {
        const elem = buscarNodo(i.elemento);
        const dest = buscarNodo(i.dest);
        if (elem && dest) {
            const copia = JSON.parse(JSON.stringify(elem));
            let nombreFinal = i.finalName ?? copia.nombre;
            if (i.finalName === undefined) {
                const existenteIdx = dest.hijos.findIndex(h => h.nombre === nombreFinal);
                if (existenteIdx !== -1) {
                    const reemplazar = i.reemplazar ?? confirm(`Ya existe \"${nombreFinal}\" en ${i.dest}. ¬øDeseas reemplazarlo? (Cancelar para renombrar)`);
                    if (reemplazar) {
                        dest.hijos.splice(existenteIdx, 1);
                        i.reemplazar = true;
                    } else {
                        i.reemplazar = false;
                        let nuevo = prompt("Introduce un nuevo nombre:", `${nombreFinal} - copia`);
                        if (!nuevo) { mostrarNotificacion("‚ÑπÔ∏è Operaci√≥n cancelada", "info"); return; }
                        nuevo = nuevo.trim();
                        while (dest.hijos.find(h => h.nombre === nuevo)) {
                            nuevo = prompt("Ese nombre ya existe. Introduce otro nombre:", `${nuevo} (1)`);
                            if (!nuevo) { mostrarNotificacion("‚ÑπÔ∏è Operaci√≥n cancelada", "info"); return; }
                            nuevo = nuevo.trim();
                        }
                        nombreFinal = nuevo;
                        i.finalName = nombreFinal;
                    }
                }
            }
            copia.nombre = nombreFinal;
            dest.hijos.push(copia);
        }
    }
    else if (i.cmd === "move") {
        const elem = buscarNodo(i.elemento);
        const partes = i.elemento.split("/").filter(Boolean);
        const nombreOriginal = partes.pop();
        const parent = buscarNodo("/" + partes.join("/"));
        const dest = buscarNodo(i.dest);
        if (elem && parent && dest) {
            let nombreFinal = i.finalName ?? nombreOriginal;
            if (i.finalName === undefined) {
                const existenteIdx = dest.hijos.findIndex(h => h.nombre === nombreFinal);
                if (existenteIdx !== -1) {
                    const reemplazar = i.reemplazar ?? confirm(`Ya existe \"${nombreFinal}\" en ${i.dest}. ¬øDeseas reemplazarlo? (Cancelar para renombrar)`);
                    if (reemplazar) {
                        dest.hijos.splice(existenteIdx, 1);
                        i.reemplazar = true;
                    } else {
                        i.reemplazar = false;
                        let nuevo = prompt("Introduce un nuevo nombre:", `${nombreFinal} (1)`);
                        if (!nuevo) { mostrarNotificacion("‚ÑπÔ∏è Operaci√≥n cancelada", "info"); return; }
                        nuevo = nuevo.trim();
                        while (dest.hijos.find(h => h.nombre === nuevo)) {
                            nuevo = prompt("Ese nombre ya existe. Introduce otro nombre:", `${nuevo} (1)`);
                            if (!nuevo) { mostrarNotificacion("‚ÑπÔ∏è Operaci√≥n cancelada", "info"); return; }
                            nuevo = nuevo.trim();
                        }
                        nombreFinal = nuevo;
                        i.finalName = nombreFinal;
                    }
                }
            }
            // Quitar del padre original y mover al destino con el nombre final
            parent.hijos = parent.hijos.filter(h => h.nombre !== nombreOriginal);
            elem.nombre = nombreFinal;
            dest.hijos.push(elem);
        }
    }
    else if (i.cmd === "delete") {
        const partes = i.elemento.split("/").filter(Boolean);
        const nombre = partes.pop();
        const parent = buscarNodo("/" + partes.join("/"));
        if (parent) parent.hijos = parent.hijos.filter(h => h.nombre !== nombre);
    }
}

function recalcularClusters() {
    const usar = contarClusters(root);
    document.getElementById("maxClusters").textContent = Math.max(maxClustersHistorico, usar);
}

function contarClusters(nodo) {
    let total = 0;
    if (nodo !== root) total += (nodo.clusters || 0);
    if (nodo.tipo === "dir") nodo.hijos.forEach(h => total += contarClusters(h));
    return total;
}

function actualizarVista() {
    const pre = document.getElementById('vista');
    pre.textContent = imprimirArbol(root);
}

function imprimirArbol(nodo, pref = "", esUltimo = true) {
    let out = "";
    if (nodo === root) {
        out = "üìÅ / (ra√≠z)\n";
    } else {
        const simbolo = esUltimo ? "‚îî‚îÄ " : "‚îú‚îÄ ";
        out = pref + simbolo + (nodo.tipo === "dir" ? "üìÅ " : "üìÑ ") + nodo.nombre + " (" + (nodo.clusters || 0) + " cl√∫ster" + (nodo.clusters !== 1 ? "s" : "") + ")\n";
    }

    if (nodo.hijos && nodo.hijos.length > 0) {
        nodo.hijos.forEach((h, idx) => {
            const esUltimoHijo = idx === nodo.hijos.length - 1;
            const nuevoPrefix = nodo === root ? "" : pref + (esUltimo ? "   " : "‚îÇ  ");
            out += imprimirArbol(h, nuevoPrefix, esUltimoHijo);
        });
    }
    return out;
}


function reconstruirDesdeCero() {
    root = {nombre: "/", tipo: "dir", hijos: [], clusters: 0};
    instrucciones.forEach(i => ejecutarInstr(i));
    recalcularClusters();
    actualizarVista();
    recalcularMaximoClusters();
}

// Calcula el m√°ximo n√∫mero de cl√∫sters usados simult√°neamente a lo largo de toda la historia
function recalcularMaximoClusters() {
    // Simular desde el principio, guardando y restaurando estado
    const snapshotInstrucciones = JSON.parse(JSON.stringify(instrucciones));

    // Simulaci√≥n en un √°rbol temporal, respetando decisiones persistidas (finalName/reemplazar)
    let tempRoot = {nombre: "/", tipo: "dir", hijos: [], clusters: 0};
    const aplicar = (i) => {
        // Crear una copia para no mutar la instrucci√≥n original durante simulaci√≥n
        const sim = JSON.parse(JSON.stringify(i));
        // Reutilizar la l√≥gica real aplic√°ndola sobre el √°rbol temporal
        const originalRoot = root;
        root = tempRoot;
        try {
            ejecutarInstr(sim);
        } finally {
            tempRoot = root;
            root = originalRoot;
        }
    };

    let maximo = 0;
    let actual = 0;
    const contar = (nodo) => {
        let total = 0;
        if (nodo !== tempRoot) total += (nodo.clusters || 0);
        if (nodo.tipo === "dir") nodo.hijos.forEach(h => total += contar(h));
        return total;
    };

    // Recorremos la historia y tras cada operaci√≥n medimos el uso actual
    tempRoot = {nombre: "/", tipo: "dir", hijos: [], clusters: 0};
    for (const ins of snapshotInstrucciones) {
        aplicar(ins);
        actual = contar(tempRoot);
        if (actual > maximo) maximo = actual;
    }

    maxClustersHistorico = maximo;
    // Refrescar la UI
    const usar = contarClusters(root);
    document.getElementById("maxClusters").textContent = Math.max(maxClustersHistorico, usar);
}

function mostrarNotificacion(mensaje, tipo) {
    // Simple alert por ahora - puedes mejorar esto con una librer√≠a de notificaciones
    console.log(`[${tipo.toUpperCase()}] ${mensaje}`);
}

// Inicializaci√≥n
actualizarFormulario();
actualizarVista();

// Animaci√≥n inversa al navegar a inicio
document.getElementById('homeLink').addEventListener('click', function(ev) {
    ev.preventDefault();
    const href = this.getAttribute('href');
    document.body.classList.add('leaving');
    setTimeout(() => { window.location.href = href; }, 320);
});
</script>
</body>
</html>